<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[读书还不够,必须练习写作]]></title>
    <url>%2F%E5%86%99%E4%BD%9C%2F2019%2F01%2F29%2F%E8%AF%BB%E4%B9%A6%E5%86%99%E4%BD%9C-%E6%9C%B1%E5%85%89%E6%BD%9C.html</url>
    <content type="text"><![CDATA[研究文学只阅读决不够，必须练习写作，世间有许多人终身在看戏、念诗、读小说，却始终不动笔写一出戏、一首诗或是一篇小说。这种人容易养成种种错误的观念：自视太低者以为写作需要一副特殊的天才，自问既没有天才，纵然写来写去，总写不到名家的那样好，倒不如索性不写为妙。自视过高者以为自己已经读了许多作品，对于文学算是内行，不写则已，写就必与众不同，于是天天在幻想将来写出如何伟大的作品，目前且慢些再说。 这两种人阅读愈多，对于写作就愈懒惰，所以有人把学问看成写作的累，以为学者与文人根本是两回事。这自然又是一个错误的观念。 只阅读而不写作的人还另有一种误解，以为自己写起来虽是平庸，看旁人的作品却有一副高明的眼光，这就是俗语所谓“眼高手低”。一般职业的批评家欢喜拿这话头来自宽自解。我自己在文艺批评中鬼混了一二十年，于今深知在文艺方面手眼必须一致，眼低者手未必高，手低者眼也未必高。你自己没有亲身体验过写作的甘苦，对于旁人的作品就难免有几分隔靴搔痒。很显著的美丑或许不难看出，而于作者苦心经营处和灵机焕发处，微言妙趣大则源于性情学问的融会，小则见于一字一句的选择与安排，你如果不曾身历其境，便难免忽略过去。 克罗齐派美学家说，要欣赏莎士比亚，你须把你自己提升到莎士比亚的水准。他们理应补充一句说：你无法把自己提升到莎士比亚的水准，除非你试过他的工作。莎士比亚的朋友本•琼森说得好。“只有诗人，而且只有第一流诗人，才配批评诗。”你如果不信这话，你试想一想：文学批评虽被认为一种专门学问，古今中外有几个自己不是写作者而成为伟大批评家的？我只想到亚理斯多德一个人，而他对于希腊诗仍有不少的隔膜处。 文学的主要功用是表现。我们如果只看旁人表现而自己不能表现，那就如哑子听人说话，人家说得愈畅快，自己愈闷得心慌。听人家说而自己不说，也不感觉闷，我不相信这种人对于文艺能有真正的热忱。人生最大的快慰是创造，一件难做的事做成了，一种闷在心里的情感或思想表现出来了，自己回头一看，就如同上帝创造了世界，母亲产出了婴儿，看到它好，自己也充分感觉到自己的力量，越发兴起鼓舞。没有尝到这种快慰的人就没有尝到文学的最大乐趣。 要彻底了解文学，要尽量欣赏文学，你必须自己动手练习创作。创作固然不是一件易事，也不是一件不可能的事。像一切有价值的活动一样，它需要辛苦学习才能做好。假定有中人之资，依着合理的程序，一步一步地向前进，有一分功夫，决有一分效果，孳孳不辍，到后来总可以达到意到笔随的程度。这事有如下围棋，一段一段地前进，功夫没有到时，慢说想跳越一段，就是想多争一颗子也不行。许多学子对文学写作不肯经过浅近的基本的训练，以为将来一动笔就会一鸣惊人，那只是妄想，虽天才也未必能做到。 练习写作有一个最重要的原则须牢记在心的，就是有话必说，无话不说，说须心口如一，不能说谎。文学本来是以语文为工具的表现艺术。心里有东西要表现，才拿语文来表现。如果心里要表现的与语文所表现的不完全相同，那就根本失去表现的功用。所谓“不完全相同”可以有两个原因，一是作者的能力不够，一是他存心要说谎。如果是能力不够，他最好认清自己能力的限度，专写自己所能写的，如是他的能力自然逐渐增进。如果是存心说谎，那是入手就走错了路，他愈写就愈入迷，离文学愈远。许多人在文学上不能有成就，大半都误在入手就养成说谎的习惯。 所谓“说谎”，有两种涵义。第一是心里那样想而口里不那样说。一个作家须有一个“我”在，须勇敢地维护他的“我”性。这事虽不容易，许多人有意或无意地在逢迎习俗，苟求欺世盗名，昧着良心去说话，其实这终究是会揭穿的。文学不是说谎的工具，你纵想说谎也无从说。“言为心声”，旁人听到你的话就会窥透你的心曲，无论你的话是真是假。 《论语》载有几句逸诗：“棠棣之华，偏其反而；岂不尔思，室斯远而。”孔子一眼就看破这话的不诚实，他说：“未之思也，夫何远之有？”作者未尝不想人相信他“岂不尔思”，但是他心里“未之思”，语言就无从表现出“思”来。他在文学上失败，在说谎上也失败了。 其次，说谎是强不知以为知。你没有上过战场，却要描写战场的生活，没有仔细研究过一个守财奴的性格，却在一篇戏剧或小说中拿守财奴做主角，尽管你的想象如何丰富，你所写的一定缺乏文学作品所必具的真实性，人不能全知，也不能全无所知。一个聪明的作家须认清自己知解的限度，小心谨慎地把眼光注视着那限度以内的事物，看清楚了，才下笔去写。如果他想超过那限度以外去摸索，他与其在浪漫派作家所谓“想象”上做功夫，不如在写实派作家所谓“证据”上做功夫，这就是说，增加生活的经验，把那限度逐渐扩大。说来说去，想象也还是要利用实际经验。 记得不肯说谎这一个基本原则，每遇到可说的话，就要抓住机会，马上就写，要极力使写出来的和心里所想的恰相符合。习文有如习画，须常备一个速写簿带在身边，遇到一片风景，一个人物，或是一种动态，觉得它新鲜有趣，可以入画，就随时速写，写得不像，再细看摆在面前的模特儿，反复修改，务求其像而后已。这种功夫做久了之后，我们一可以养成爱好精确的习惯，二可以逐渐养成艺术家看事物的眼光，在日常生活中时时可发现值得表现的情境；三可以增进写作的技巧，逐渐使难写的成为易写。 在初写时，我们必须谨守着知道清楚的，和易于着笔的这两种材料的范围。我把这两层分开来说，其实最重要的条件还是知得清楚，知得不清楚就不易于着笔。我们一般人至少对于自己日常生活知得比较清楚，所以记日记是初学习作的最好的方法。普通记日记只如记流水帐，或是作干燥无味的起居注，那自然与文学无干。把日记当作一种文学的训练，就要把本身有趣的材料记得有趣。如果有相当的敏感，到处留心，一日之内值得记的见闻感想决不会缺乏。 一番家常的淡话，一个新来的客，街头一阵喧嚷，花木风云的一种新变化，读书看报得到的一阵感想，听来的一件故事，总之，一切动静所生的印象，都可以供你细心描绘，成为好文章。你不必预定每天应记的字数，只要把应记的记得恰到好处，长则数百字，短则数十字，都可不拘。你也不必在一天之内同时记许多事，多记难免如“数莱菔下窖”，决不会记得好。选择是文学的最重要的功夫，你每天选一件最值得记的，把它记得妥妥帖帖，记成一件“作品”出来，那就够了。 宇宙间一切现象都可以纳到四大范畴里去，就是情理事态。情指喜怒哀乐之类主观的感动，理是思想在事物中所推求出来的条理秩序，事包含一切人物的动作，态指人物的形状。文字的材料就不外这四种。因此文学的功用通常分为言情、说理、叙事、绘态（亦称状物或描写）四大类。 文学作品因体裁不同对这四类功用各有所偏重。例如诗歌侧重言情，论文侧重说理，历史、戏剧、小说都侧重叙事，山水人物杂记侧重绘态。这自然是极粗浅的分别，实际上情理事态常交错融贯，事必有态，情常寓理，不易拆开。有些文学课本把作品分为言情，说理，叙事，绘态四类，未免牵强。一首诗、一出戏或一篇小说，可以时而言情说理，时而叙事绘态。纯粹属于某一类的作品颇不易找出，作品的文学价值愈高，愈是情理事态打成一片。 不过在习作时，我们不妨记起这四类的分别，因为四类作法对于初学有难有易，初学宜由易而难，循序渐进。从前私塾国文教员往往入手就教学生作论说，至今这个风气仍在学校里流行。这办法实在不妥。说理文需要丰富的学识和谨严的思考。这恰是青年人通常所缺乏的。他们没有说理文所必具的条件而勉强做说理文，势必袭陈腐的滥调，发空洞的议论。我有时看到大学生的国文试卷，常是满纸“大凡天下”，学理工者也是如此，因而深深地感觉到不健康的语文教育可以酿成思想糊涂。 早习说理文的坏处还不仅此。青年期想象力较丰富，所谓“想象”是指运用具体的意象去思想，与我们一般成年人运用抽象的概念去思想不同。这两种思想类型的分别恰是文艺与科学的分别。所以有志习文学创作者必须趁想象力丰富时期，学会驾驭具体的情境，让世界本其光热色相活现于眼前，不只是一些无血无肉的冷冰冰的理。舍想象不去发展，只耗精力于说理，结果心里就只会有“理”而不会有“象”，那就是说，养成一种与文艺相反的习惯。我自己吃过这亏，所以知道很清楚。 现代许多文学青年欢喜写抒情诗文。我曾做过一个文艺刊物的编辑，收到的青年作家的稿件以抒情诗文为最多。文学本是表现情感的，青年人是最富于情感的，这两件事实凑拢起来，当然的结论是青年人是爱好文学的。在事实上许多青年人走上文学的路，也确是因为他们需要发泄情感。不过就习作说，入手就写言情诗文仍是不妥当。 第一，情感迷离恍惚，不易捉摸，正如梦中不易说梦，醉中只觉陶陶。诗人华兹华斯说得好：“诗起于沉静中回味得来的情绪”，意与中文成语“痛定思痛”相近。青年人容易感受情绪，却不容易于沉静中回味情绪，感受情绪而加以沉静回味是始而“入乎其中”，继而“出乎其外”，这需要相当的修养。 回味之后，要把情绪表现出来，也不能悲即言悲，喜即言喜，必须使情绪融化于具体的意象，或寓情于事，如“步出城东门，遥望江南路，前日风雪中，故人从此去”，不言惜别而惜别自见；或寓情于景（即本文所谓态），如“西风残照，汉家陵阙”，不言悲凉而悲凉自见。所以言情必借叙事绘态，如果没有先学叙事绘态，言情文决不易写得好。 现在一般青年作家只知道抽象地说悲说喜，再加上接二连三的惊叹号，以为这就算尽了言情的能事。悲即言悲，喜即言喜，谁不会？堆砌惊叹号，谁不会？只是你言悲言喜而读者不悲不喜，你用惊叹号而读者并不觉有惊叹的必要，那还算得什么文学作品？ 其次，情感自身也需要陶冶熔炼，才值得文学表现。人生经验愈丰富，事理观察愈深刻，情感也就愈沉着，愈易融化于具体的情感。最沉痛的言情诗文往往不是一个作家的早年作品，我们的屈原、庾信、杜甫和苏轼，西方的但丁、莎士比亚和歌德都可以为证。青年人的情感来得容易，也来得浮泛，十个人失恋就有九个人要悲观自杀，就有九个人表现同样的姿态，过了一些时候，就有九个人都仍旧欢天喜地过日子。他们的言情作品往往表现一种浅薄的感伤主义，即西方人所谓sentimentalism。这恰是上品言情文的大忌讳。 为初学写作者说法，说理文可缓作，言情文也可缓作，剩下来的只有叙事绘态两种。事与态都是摆在眼前的，极具体而有客观性，比较容易捉摸，好比习画写生，模特儿摆在面前，看着它一笔一笔地模拟，如果有一笔不像，还可以随看随改。紧抓住实事实物，决不至堕入空洞肤泛的恶习。 叙事与绘态之中还是叙事最要紧。叙事其实就是绘动态，能绘动态就能绘静态。纯粹的绘静态文极易流于呆板，而且在事实上也极少见。事物不能很久地留在静态中，离静而动，即变为事，即成为叙事的对象。因此叙事文与绘态文极不易分，叙事文即于叙事中绘态，绘态文也必夹叙事才能生动。 叙事文与绘态文做好了，其他各体文目可迎刃而解，因为严格地说，情与理还是心理方面的动作，还是可以认成“事”，还是有它们的“态”，所不同者它们比较偏于主观的，不如一般外在事态那样容易着笔。在外在事态上下过一番功夫，然后再以所得的娴熟的手腕去应付内在的事态（即情理），那就没有多大困难了。 本文完 概括： 文学的功用是表现,研究文学,仅仅阅读不够,必须亲自下笔写作表达。写作要遵守不说谎原则：不要心口不一；不要写自己不懂，超出能力范围的。谨守着知道清楚的和易于着笔的这两种材料的范围练习写作,初学写作,最好先学叙事,随身拿笔记本,把生活中有趣的事，物仔细的记载下来,并且反复修改,直到到成为自己心中理想模样，不必刻意追求字数，如此坚持下去总会有进步。]]></content>
      <categories>
        <category>写作</category>
      </categories>
      <tags>
        <tag>读书</tag>
        <tag>写作</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[工具]]></title>
    <url>%2F%E6%A0%BC%E5%BC%8F%E6%A8%A1%E6%9D%BF%2F2019%2F01%2F23%2F%E5%86%99%E4%BD%9C%E6%A8%A1%E6%9D%BF.html</url>
    <content type="text"><![CDATA[0x00 系列文章目录 天上掉下个猪八戒 夺宝幸运星0x01 摘要摘要正文由于我设置描述当做摘要，这个时候文章中的已经不起作用。 0x02 正文2.1 二级标题2.1.1 三级标题我简要说几点： 第一点 第二点 第三点 0xFE 总结这是一个总结 0xFF 参考文档猫和老鼠]]></content>
      <categories>
        <category>格式模板</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
        <tag>标签3</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[hello world]]></title>
    <url>%2F%E6%96%87%E6%A1%A3%2F2019%2F01%2F23%2Fhello-world.html</url>
    <content type="text"><![CDATA[Welcome to Hexo! This is your very first post. Check documentation for more info. If you get any problems when using Hexo, you can find the answer in troubleshooting or you can ask me on GitHub. Quick StartCreate a new post1$ hexo new "My New Post" More info: Writing Run server1$ hexo server More info: Server Generate static files1$ hexo generate More info: Generating Deploy to remote sites1$ hexo deploy More info: Deployment]]></content>
      <categories>
        <category>文档</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[测试文档2]]></title>
    <url>%2Fpython%E5%AD%A6%E4%B9%A0%2F2019%2F01%2F23%2Fpython%E6%B5%8B%E8%AF%95%E6%96%87%E6%A1%A3.html</url>
    <content type="text"><![CDATA[The Algorithms - Python All algorithms implemented in Python (for education)These implementations are for demonstration purposes. They are less efficient than the implementations in the Python standard library. Sorting AlgorithmsBubble Sort Bubble sort, sometimes referred to as sinking sort, is a simple sorting algorithm that repeatedly steps through the list to be sorted, compares each pair of adjacent items and swaps them if they are in the wrong order. The pass through the list is repeated until no swaps are needed, which indicates that the list is sorted. Properties Worst case performance O(n2) Best case performance O(n) Average case performance O(n2) Source: WikipediaView the algorithm in actionBucket Bucket sort, or bin sort, is a sorting algorithm that works by distributing the elements of an array into a number of buckets. Each bucket is then sorted individually, either using a different sorting algorithm, or by recursively applying the bucket sorting algorithm. Properties Worst case performance O(n2) Best case performance O(n+k) Average case performance O(n+k) Source: WikipediaCocktail shaker Cocktail shaker sort, also known as bidirectional bubble sort, cocktail sort, shaker sort (which can also refer to a variant of selection sort), ripple sort, shuffle sort, or shuttle sort, is a variation of bubble sort that is both a stable sorting algorithm and a comparison sort. The algorithm differs from a bubble sort in that it sorts in both directions on each pass through the list. Properties Worst case performance O(n2) Best case performance O(n) Average case performance O(n2) Source: WikipediaInsertion Sort Insertion sort is a simple sorting algorithm that builds the final sorted array (or list) one item at a time. It is much less efficient on large lists than more advanced algorithms such as quicksort, heapsort, or merge sort. Properties Worst case performance O(n2) Best case performance O(n) Average case performance O(n2) Source: WikipediaView the algorithm in actionMerge Sort Merge sort (also commonly spelled mergesort) is an efficient, general-purpose, comparison-based sorting algorithm. Most implementations produce a stable sort, which means that the implementation preserves the input order of equal elements in the sorted output. Mergesort is a divide and conquer algorithm that was invented by John von Neumann in 1945. Properties Worst case performance O(n log n) Best case performance O(n log n) Average case performance O(n log n) Source: WikipediaView the algorithm in actionQuick Quicksort (sometimes called partition-exchange sort) is an efficient sorting algorithm, serving as a systematic method for placing the elements of an array in order. Properties Worst case performance O(n2) Best case performance O(n log n) or O(n) with three-way partition Average case performance O(n log n) Source: WikipediaView the algorithm in actionHeapHeapsort is a comparison-based sorting algorithm. It can be thought of as an improved selection sort. It divides its input into a sorted and an unsorted region, and it iteratively shrinks the unsorted region by extracting the largest element and moving that to the sorted region. Properties Worst case performance O(n log n) Best case performance O(n log n) Average case performance O(n log n) Source: WikipediaView the algorithm in actionRadixFrom Wikipedia: Radix sort is a non-comparative integer sorting algorithm that sorts data with integer keys by grouping keys by the individual digits which share the same significant position and value. Properties Worst case performance O(wn) Best case performance O(wn) Average case performance O(wn) Source: WikipediaSelection Selection sort is an algorithm that divides the input list into two parts: the sublist of items already sorted, which is built up from left to right at the front (left) of the list, and the sublist of items remaining to be sorted that occupy the rest of the list. Initially, the sorted sublist is empty and the unsorted sublist is the entire input list. The algorithm proceeds by finding the smallest (or largest, depending on sorting order) element in the unsorted sublist, exchanging (swapping) it with the leftmost unsorted element (putting it in sorted order), and moving the sublist boundaries one element to the right. Properties Worst case performance O(n2) Best case performance O(n2) Average case performance O(n2) Source: WikipediaView the algorithm in actionShell Shellsort is a generalization of insertion sort that allows the exchange of items that are far apart. The idea is to arrange the list of elements so that, starting anywhere, considering every nth element gives a sorted list. Such a list is said to be h-sorted. Equivalently, it can be thought of as h interleaved lists, each individually sorted. Properties Worst case performance O(nlog2n) Best case performance O(n log n) Average case performance depends on gap sequence Source: WikipediaView the algorithm in actionTopologicalFrom Wikipedia: Topological sort, or topological ordering of a directed graph is a linear ordering of its vertices such that for every directed edge _uv_ from vertex _u_ to vertex _v_, _u_ comes before _v_ in the ordering. For instance, the vertices of the graph may represent tasks to be performed, and the edges may represent constraints that one task must be performed before another; in this application, a topological ordering is just a valid sequence for the tasks. A topological ordering is possible if and only if the graph has no directed cycles, that is, if it is a directed acyclic graph (DAG). Any DAG has at least one topological ordering, and algorithms are known for constructing a topological ordering of any DAG in linear time. Time-Complexity GraphsComparing the complexity of sorting algorithms (Bubble Sort, Insertion Sort, Selection Sort) Comparing the sorting algorithms: -Quicksort is a very fast algorithm but can be pretty tricky to implement -Bubble sort is a slow algorithm but is very easy to implement. To sort small sets of data, bubble sort may be a better option since it can be implemented quickly, but for larger datasets, the speedup from quicksort might be worth the trouble implementing the algorithm. Search AlgorithmsLinear Linear search or sequential search is a method for finding a target value within a list. It sequentially checks each element of the list for the target value until a match is found or until all the elements have been searched. Linear search runs in at worst linear time and makes at most n comparisons, where n is the length of the list. Properties Worst case performance O(n) Best case performance O(1) Average case performance O(n) Worst case space complexity O(1) iterative Source: WikipediaBinary Binary search, also known as half-interval search or logarithmic search, is a search algorithm that finds the position of a target value within a sorted array. It compares the target value to the middle element of the array; if they are unequal, the half in which the target cannot lie is eliminated and the search continues on the remaining half until it is successful. Properties Worst case performance O(log n) Best case performance O(1) Average case performance O(log n) Worst case space complexity O(1) Source: WikipediaInterpolationInterpolation search is an algorithm for searching for a key in an array that has been ordered by numerical values assigned to the keys (key values). It was first described by W. W. Peterson in 1957.[1] Interpolation search resembles the method by which people search a telephone directory for a name (the key value by which the book’s entries are ordered): in each step the algorithm calculates where in the remaining search space the sought item might be, based on the key values at the bounds of the search space and the value of the sought key, usually via a linear interpolation. The key value actually found at this estimated position is then compared to the key value being sought. If it is not equal, then depending on the comparison, the remaining search space is reduced to the part before or after the estimated position. This method will only work if calculations on the size of differences between key values are sensible. By comparison, binary search always chooses the middle of the remaining search space, discarding one half or the other, depending on the comparison between the key found at the estimated position and the key sought — it does not require numerical values for the keys, just a total order on them. The remaining search space is reduced to the part before or after the estimated position. The linear search uses equality only as it compares elements one-by-one from the start, ignoring any sorting. On average the interpolation search makes about log(log(n)) comparisons (if the elements are uniformly distributed), where n is the number of elements to be searched. In the worst case (for instance where the numerical values of the keys increase exponentially) it can make up to O(n) comparisons. In interpolation-sequential search, interpolation is used to find an item near the one being searched for, then linear search is used to find the exact item. Source: WikipediaJump SearchJump search or block search refers to a search algorithm for ordered lists. It works by first checking all items Lkm, where {\displaystyle k\in \mathbb {N} } k\in \mathbb {N} and m is the block size, until an item is found that is larger than the search key. To find the exact position of the search key in the list a linear search is performed on the sublist L[(k-1)m, km]. The optimal value of m is √n, where n is the length of the list L. Because both steps of the algorithm look at, at most, √n items the algorithm runs in O(√n) time. This is better than a linear search, but worse than a binary search. The advantage over the latter is that a jump search only needs to jump backwards once, while a binary can jump backwards up to log n times. This can be important if a jumping backwards takes significantly more time than jumping forward. The algorithm can be modified by performing multiple levels of jump search on the sublists, before finally performing the linear search. For an k-level jump search the optimum block size ml for the lth level (counting from 1) is n(k-l)/k. The modified algorithm will perform k backward jumps and runs in O(kn1/(k+1)) time. Source: WikipediaQuick Select Quick Select is a selection algorithm to find the kth smallest element in an unordered list. It is related to the quicksort sorting algorithm. Like quicksort, it was developed by Tony Hoare, and thus is also known as Hoare’s selection algorithm.[1] Like quicksort, it is efficient in practice and has good average-case performance, but has poor worst-case performance. Quickselect and its variants are the selection algorithms most often used in efficient real-world implementations. Quickselect uses the same overall approach as quicksort, choosing one element as a pivot and partitioning the data in two based on the pivot, accordingly as less than or greater than the pivot. However, instead of recursing into both sides, as in quicksort, quickselect only recurses into one side – the side with the element it is searching for. This reduces the average complexity from O(n log n) to O(n), with a worst case of O(n2). As with quicksort, quickselect is generally implemented as an in-place algorithm, and beyond selecting the k’th element, it also partially sorts the data. See selection algorithm for further discussion of the connection with sorting. Source: WikipediaTabuTabu search uses a local or neighborhood search procedure to iteratively move from one potential solution {\displaystyle x} x to an improved solution {\displaystyle x’} x’ in the neighborhood of {\displaystyle x} x, until some stopping criterion has been satisfied (generally, an attempt limit or a score threshold). Local search procedures often become stuck in poor-scoring areas or areas where scores plateau. In order to avoid these pitfalls and explore regions of the search space that would be left unexplored by other local search procedures, tabu search carefully explores the neighborhood of each solution as the search progresses. The solutions admitted to the new neighborhood, {\displaystyle N^{}(x)} N^(x), are determined through the use of memory structures. Using these memory structures, the search progresses by iteratively moving from the current solution {\displaystyle x} x to an improved solution {\displaystyle x’} x’ in {\displaystyle N^{}(x)} N^(x). These memory structures form what is known as the tabu list, a set of rules and banned solutions used to filter which solutions will be admitted to the neighborhood {\displaystyle N^{}(x)} N^(x) to be explored by the search. In its simplest form, a tabu list is a short-term set of the solutions that have been visited in the recent past (less than {\displaystyle n} n iterations ago, where {\displaystyle n} n is the number of previous solutions to be stored — is also called the tabu tenure). More commonly, a tabu list consists of solutions that have changed by the process of moving from one solution to another. It is convenient, for ease of description, to understand a “solution” to be coded and represented by such attributes. Source: Wikipedia CiphersCaesar![alt text][caesar] Caesar cipher, also known as Caesar’s cipher, the shift cipher, Caesar’s code or Caesar shift, is one of the simplest and most widely known encryption techniques.It is a type of substitution cipher in which each letter in the plaintext is replaced by a letter some fixed number of positions down the alphabet. For example, with a left shift of 3, D would be replaced by A, E would become B, and so on. The method is named after Julius Caesar, who used it in his private correspondence.The encryption step performed by a Caesar cipher is often incorporated as part of more complex schemes, such as the Vigenère cipher, and still has modern application in the ROT13 system. As with all single-alphabet substitution ciphers, the Caesar cipher is easily broken and in modern practice offers essentially no communication security. Source: WikipediaVigenèreVigenère cipher is a method of encrypting alphabetic text by using a series of interwoven Caesar ciphers based on the letters of a keyword. It is a form of polyalphabetic substitution.The Vigenère cipher has been reinvented many times. The method was originally described by Giovan Battista Bellaso in his 1553 book La cifra del. Sig. Giovan Battista Bellaso; however, the scheme was later misattributed to Blaise de Vigenère in the 19th century, and is now widely known as the “Vigenère cipher”.Though the cipher is easy to understand and implement, for three centuries it resisted all attempts to break it; this earned it the description le chiffre indéchiffrable(French for ‘the indecipherable cipher’).Many people have tried to implement encryption schemes that are essentially Vigenère ciphers. Friedrich Kasiski was the first to publish a general method of deciphering a Vigenère cipher in 1863. Source: WikipediaTranspositionTransposition cipher is a method of encryption by which the positions held by units of plaintext (which are commonly characters or groups of characters) are shifted according to a regular system, so that the ciphertext constitutes a permutation of the plaintext. That is, the order of the units is changed (the plaintext is reordered). Mathematically a bijective function is used on the characters’ positions to encrypt and an inverse function to decrypt. Source: WikipediaRSA (Rivest–Shamir–Adleman)RSA (Rivest–Shamir–Adleman) is one of the first public-key cryptosystems and is widely used for secure data transmission. In such a cryptosystem, the encryption key is public and it is different from the decryption key which is kept secret (private). In RSA, this asymmetry is based on the practical difficulty of the factorization of the product of two large prime numbers, the “factoring problem”. The acronym RSA is made of the initial letters of the surnames of Ron Rivest, Adi Shamir, and Leonard Adleman, who first publicly described the algorithm in 1978. Clifford Cocks, an English mathematician working for the British intelligence agency Government Communications Headquarters (GCHQ), had developed an equivalent system in 1973, but this was not declassified until 1997.[1] A user of RSA creates and then publishes a public key based on two large prime numbers, along with an auxiliary value. The prime numbers must be kept secret. Anyone can use the public key to encrypt a message, but with currently published methods, and if the public key is large enough, only someone with knowledge of the prime numbers can decode the message feasibly.[2] Breaking RSA encryption is known as the RSA problem. Whether it is as difficult as the factoring problem remains an open question. Source: Wikipedia)ROT13 ROT13 (“rotate by 13 places”, sometimes hyphenated ROT-13) is a simple letter substitution cipher that replaces a letter with the 13th letter after it, in the alphabet. ROT13 is a special case of the Caesar cipher which was developed in ancient Rome. Because there are 26 letters (2×13) in the basic Latin alphabet, ROT13 is its own inverse; that is, to undo ROT13, the same algorithm is applied, so the same action can be used for encoding and decoding. The algorithm provides virtually no cryptographic security, and is often cited as a canonical example of weak encryption.[1] Source: WikipediaXORXOR cipher is a simple type of additive cipher,[1] an encryption algorithm that operates according to the principles: A {\displaystyle \oplus } \oplus 0 = A,A {\displaystyle \oplus } \oplus A = 0,(A {\displaystyle \oplus } \oplus B) {\displaystyle \oplus } \oplus C = A {\displaystyle \oplus } \oplus (B {\displaystyle \oplus } \oplus C),(B {\displaystyle \oplus } \oplus A) {\displaystyle \oplus } \oplus A = B {\displaystyle \oplus } \oplus 0 = B,where {\displaystyle \oplus } \oplus denotes the exclusive disjunction (XOR) operation. This operation is sometimes called modulus 2 addition (or subtraction, which is identical).[2] With this logic, a string of text can be encrypted by applying the bitwise XOR operator to every character using a given key. To decrypt the output, merely reapplying the XOR function with the key will remove the cipher. Source: Wikipedia]]></content>
      <categories>
        <category>python学习</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[教育的目的]]></title>
    <url>%2F%E6%95%99%E8%B5%84%2F2019%2F01%2F23%2F%E6%95%99%E8%82%B2%E7%9A%84%E7%9B%AE%E7%9A%84.html</url>
    <content type="text"><![CDATA[概述狭义教育目的：国家对受教育者的总的要求 教育目的是教育的出发点和归属 教育目的-国家 培养目标-学校 课程目标-学科 教学目标-课堂 教育方针包括教育目的。 教育目的的意义和价值 导向 激励 评价 价值取向 个人本位论:looks福尔泰 卢梭 洛克 夸美纽斯 福禄贝尔 裴氏泰洛奇 社会本位论:饼干上两个孔 斯宾塞 涂尔干 赫尔巴特(两) 孔子 孔德 教育无目的论：杜威：教育过程就是目的 教育辩证统一论 我国教育目的 培养社会主义接班人，德育和智育统一。 德智体美劳全面发展。脑力和体力两开花。 适应时代要求，强调学生个性发展，培养学生创造和实践能力。 ps:创新和实践是素质教育的重点,其中创新是素质教育的核心。素质教育的理论依据：马克思主义关于人的全面发展学说 旧的社会分工是人片面发展的根源 教育与生产劳动相结合是全面发展的根本途径 德育-灵魂，统帅 **智育(具体要求)不仅仅包括提高智商。 掌握基础知识和技能 培养能力 改善各种非认知因素** 体育 主要体育课 美育(蔡元培最早引入)(学界泰斗，人世楷模) 感受美：起点 鉴赏美 创造美：最高目标 劳动技术教育]]></content>
      <categories>
        <category>教资</category>
      </categories>
      <tags>
        <tag>标签1</tag>
        <tag>标签2</tag>
      </tags>
  </entry>
</search>
